

# ‚òÅÔ∏è Cloud Networking Special Topic  
## TCP SYN Backlog & Connection Queue Internals  
*(How servers survive connection floods and accept millions of clients)*  

**Written By: Vinod N. Rathod**

---

## üß† Why Connection Handling Matters

Before any application can exchange data, a TCP connection must be established.

That process seems simple:

Client ‚Üí Connect Server ‚Üí Accept

But internally, the kernel must:

- Track half-open connections
- Allocate memory
- Validate handshake
- Manage queues
- Protect against abuse

Connection handling is one of the most performance-critical parts of networking.

---

## üéØ The Core Problem

Servers can‚Äôt instantly accept unlimited connections.

They must stage them in queues while handshakes complete.

If too many arrive at once:

- Queues overflow
- Connections drop
- Clients retry
- Load multiplies

This is where backlog queues come in.

---

## üß± TCP Three-Way Handshake Refresher

TCP connection setup:

1. Client ‚Üí SYN


2. Server ‚Üí SYN-ACK


3. Client ‚Üí ACK



Only after step 3 does the connection become **fully established**.

Before that, it‚Äôs only *half open*.

Kernel must track these incomplete connections safely.

---

## üß± Two Queues Inside the Kernel

Linux maintains two separate queues for incoming connections.

---

### 1Ô∏è‚É£ SYN Queue (Half-Open Queue)

Stores connections that sent SYN but haven‚Äôt completed handshake.

Contains:
- Source IP
- Sequence numbers
- Timers

Purpose:
Track handshake progress.

---

### 2Ô∏è‚É£ Accept Queue (Established Queue)

Stores fully established connections waiting for application to accept them.

Flow:

Handshake completes ‚Üí connection enters accept queue ‚Üí application calls accept() ‚Üí connection handed to app

If application is slow to accept, queue fills.

---

## üîÅ Connection Lifecycle Through Queues

Full flow:

Client sends SYN ‚Üí added to SYN queue Client sends ACK ‚Üí moved to accept queue App calls accept() ‚Üí connection delivered

Each step depends on queue capacity.

---

## üí• What Happens When Queues Fill

---

### SYN Queue Overflow

If SYN queue is full:

- New SYN packets dropped
- Clients retry
- Traffic increases

Looks like:
> Server unreachable

Even though server is alive.

---

### Accept Queue Overflow

If accept queue fills:

- Handshake succeeds
- Kernel cannot deliver connection to app
- Connection reset or delayed

This causes:

- Latency spikes
- Connection failures
- Timeouts

---

## üß† Why This Happens in Real Systems

Queue overflow often occurs because:

- Traffic spikes
- Application slow to accept
- Thread starvation
- CPU overload
- Lock contention

Network is fine.  
Kernel queues are overloaded.

---

## üåê SYN Flood Attacks

Attackers exploit SYN queue behavior.

They send many SYN packets but never complete handshake.

Result:

- SYN queue fills
- Legit clients blocked

This is called a **SYN flood attack**.

It targets connection state, not bandwidth.

---

## üõ°Ô∏è Kernel Protection Mechanisms

---

### 1Ô∏è‚É£ SYN Cookies

Instead of storing connection state:

- Kernel encodes state into SYN-ACK sequence number
- Doesn‚Äôt allocate memory until final ACK

Benefits:
- Protects SYN queue
- Prevents memory exhaustion

Used automatically during overload.

---

### 2Ô∏è‚É£ Backlog Limits

Kernel parameters define queue sizes:

- `somaxconn`
- `tcp_max_syn_backlog`

Increasing them allows more pending connections.

But:
Large queues increase memory usage.

---

### 3Ô∏è‚É£ SYN Rate Limiting

Kernel can:

- Drop excessive SYNs
- Slow responses
- Prioritize valid clients

Protects against floods.

---

## üß† Accept Queue Bottlenecks

Even if kernel handles connections, application must accept them.

Slow apps cause:

- Backlog buildup
- Latency spikes
- Client retries
- Traffic amplification

This is why high-performance servers use:

- Non-blocking accept loops
- Multiple worker processes
- Event-driven architectures

Connection handling must scale with traffic.

---

## üèóÔ∏è How High-Scale Systems Handle Millions of Connections

Large-scale platforms use:

- SO_REUSEPORT for parallel accept
- Multiple listener threads
- Kernel tuning
- Load balancer frontends
- Connection offloading

Goal:
Distribute connection handling across CPUs.

One thread cannot handle millions of clients.

---

## üîê Security Implications

Connection queues are a major attack surface.

Threats:

- SYN floods
- Connection exhaustion
- Resource starvation
- Bot traffic spikes

Modern defenses include:

- SYN cookies
- Rate limiting
- Anycast filtering
- SmartNIC mitigation

Protecting queues is protecting availability.

---

## üßæ Quick Recap

| Queue | Role |
|------|------|
| SYN Queue | Tracks half-open connections |
| Accept Queue | Holds ready connections |
| Overflow | Drops connections |
| SYN Cookies | Stateless defense |
| Backlog | Queue capacity limit |
| Goal | Handle spikes safely |

---

## ‚ö° In Simple Terms

Before your app talks to a client,  
the kernel must hold that client in line.

Too many clients ‚Üí line overflows ‚Üí connections fail.

Servers don‚Äôt crash because bandwidth is full.  
They crash because **their connection queues are full**.

Networking performance often depends not on speed‚Ä¶  
but on how well you manage waiting lines.

---

**~ V1NNN22 ~**  
**THANK YOU!**
