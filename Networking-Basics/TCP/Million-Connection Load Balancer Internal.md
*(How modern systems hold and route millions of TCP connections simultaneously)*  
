# ‚òÅÔ∏è Cloud Networking Special Topic  
## Million-Connection Load Balancer Internals  
*(How modern systems hold and route millions of TCP connections simultaneously)*  

**Written By: Vinod N. Rathod**

---

## üß† The Real Challenge of Load Balancing at Scale

Handling traffic is easy.

Handling **millions of simultaneous connections** is hard.

Modern systems must support:

- Long-lived connections
- Persistent HTTP/2 streams
- WebSockets
- gRPC channels
- Streaming clients

A single load balancer may maintain:

> Millions of active TCP sessions at once

The real problem isn‚Äôt bandwidth.  
It‚Äôs connection state.

---

## üéØ Why Connection Scaling Is Difficult

Each TCP connection requires state:

- Source/destination IP
- Ports
- Sequence numbers
- Window sizes
- Timers
- Retransmission data

Multiply that by:

1,000,000 connections

You get:

- Massive memory usage
- CPU tracking overhead
- Timer management load
- Kernel structure pressure

Connection state becomes the bottleneck.

---

## üß± Core Internal Components of a High-Scale Load Balancer

---

## 1Ô∏è‚É£ Connection Table

Load balancers maintain a large table mapping:

Client ‚Üî Backend

Example entry:

Client 1.2.3.4:52311 ‚Üí Backend 10.0.2.7:443

Table must support:

- Fast lookup
- Fast insert
- Fast delete
- Concurrent access

Usually implemented using:

- Hash tables
- Lock-free maps
- CPU-sharded structures

Lookup must happen in microseconds.

---

## 2Ô∏è‚É£ State Tracking Engine

Each connection needs lifecycle tracking:

States:

- SYN received
- Established
- Idle
- Closing
- Closed

Load balancer must:

- Update states quickly
- Remove expired entries
- Avoid leaks

If stale connections accumulate ‚Üí memory exhaustion.

---

## 3Ô∏è‚É£ Timer System

Every connection has timers:

- Idle timeout
- Retransmission timeout
- Keepalive timeout
- FIN timeout

Millions of connections = millions of timers.

Efficient timer systems use:

- Timing wheels
- Bucketed timers
- Hierarchical timers

Naive timer implementations collapse under scale.

---

## 4Ô∏è‚É£ Kernel vs User-Space Handling

High-performance load balancers often avoid kernel networking for connection handling.

Instead they use:

- DPDK
- eBPF/XDP
- User-space TCP stacks
- Custom packet engines

Reason:
Kernel per-connection overhead is too expensive.

---

## üåê How Load Balancers Distribute Work Across CPUs

Modern load balancers must scale horizontally inside one machine.

They distribute connections using:

- RSS hashing
- CPU affinity
- Queue pinning
- Per-core connection tables

Design rule:

> One core should not manage all connections.

Instead:

Core 1 ‚Üí subset of connections Core 2 ‚Üí subset Core 3 ‚Üí subset

This avoids lock contention.

---

## üîÅ Stateless vs Stateful Load Balancing

---

### Stateful Load Balancing

Tracks each connection.

Advantages:
- Precise routing
- Sticky sessions
- Full control

Disadvantages:
- Memory heavy
- Scaling limits
- Failover complexity

---

### Stateless Load Balancing

Does not track connections.

Uses:

- Hashing
- Anycast routing
- Consistent hashing

Advantages:
- Infinite scale
- Simpler failover
- Less memory usage

Disadvantages:
- Less control
- Harder debugging

Hyperscalers often combine both.

---

## üí• Failure Mode: Connection Explosion

Traffic spikes can create connection storms.

Example:

- 100k users reconnect simultaneously
- Each opens multiple connections
- Load balancer sees millions instantly

If system isn‚Äôt prepared:

- Connection table overflows
- Memory spikes
- CPU stalls
- Requests fail

Scaling must handle sudden spikes, not just steady load.

---

## üß† Optimization Techniques Used by Hyperscalers

Large-scale load balancers optimize heavily.

Techniques include:

- Connection reuse
- TCP multiplexing
- Keepalive tuning
- Idle connection pruning
- Adaptive timeouts
- SYN proxying

They aim to:

> Reduce number of active connections without reducing traffic.

---

## üîê Security Challenges

Connection-heavy systems are vulnerable to:

- SYN floods
- Connection exhaustion
- Bot storms
- Slowloris attacks
- Idle connection abuse

Protection methods:

- SYN cookies
- Rate limiting
- Connection caps
- Idle pruning
- Per-IP quotas

Connection handling is both performance and security problem.

---

## üèóÔ∏è Real-World Hyperscaler Designs

Large cloud providers use:

- Layered load balancing
- Edge termination
- Regional balancing
- Anycast routing
- Hardware offload
- SmartNIC processing

Traffic is distributed across:

- Multiple machines
- Multiple racks
- Multiple regions

No single load balancer handles everything.

Scale is achieved through distribution.

---

## üßæ Quick Recap

| Component | Role |
|--------|------|
| Connection Table | Maps clients to backends |
| Timers | Track connection lifecycle |
| CPU Sharding | Distribute load |
| Stateful LB | Tracks connections |
| Stateless LB | Hash-based routing |
| Goal | Millions of connections safely |

---

## ‚ö° In Simple Terms

Bandwidth doesn‚Äôt break load balancers.

Connections do.

Handling millions of connections means:

- Tracking state
- Managing memory
- Scheduling timers
- Avoiding locks
- Distributing work

The hardest part of load balancing isn‚Äôt sending packets.  
It‚Äôs remembering who‚Äôs talking to whom.

---

**~ V1NNN22 ~**  
**THANK YOU!**


